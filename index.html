<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cosmic Portfolio</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background-color: black; 
    }
    canvas { display: block; }
    #info { 
      position: absolute; 
      top: 10px; 
      left: 10px; 
      color: white; 
      z-index: 1; 
    }
  </style>
</head>
<body>
  <div id="info">Cliquez sur une étoile ou une planète</div>
  <script type="module">
    // Importer les modules de Three.js depuis le CDN
    import * as THREE from 'https://unpkg.com/three@0.152.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.152.0/examples/jsm/controls/OrbitControls.js';

    // Initialisation de la scène, de la caméra et du renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 50);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // OrbitControls pour naviguer dans l'espace
    const controls = new OrbitControls(camera, renderer.domElement);

    // Lumières
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const pointLight = new THREE.PointLight(0xffffff, 1);
    pointLight.position.set(0, 0, 0);
    scene.add(pointLight);

    // Création d'un arrière-plan d'étoiles (simple système de particules)
    function createStarField() {
      const starsGeometry = new THREE.BufferGeometry();
      const starsCount = 5000;
      const positions = new Float32Array(starsCount * 3);
      for (let i = 0; i < starsCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 1000;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 1000;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 1000;
      }
      starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff });
      const starField = new THREE.Points(starsGeometry, starsMaterial);
      scene.add(starField);
    }
    createStarField();

    // Fonction utilitaire pour créer un système solaire
    function createSolarSystem(position, title) {
      const group = new THREE.Group();
      group.position.copy(position);

      // Étoile centrale (cliquable)
      const starGeometry = new THREE.SphereGeometry(2, 32, 32);
      const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const star = new THREE.Mesh(starGeometry, starMaterial);
      star.name = title + ' System';
      group.add(star);

      // Planètes
      const planetData = [
        { angle: 0, distance: 5, color: 'lightblue', name: title + ' 1' },
        { angle: Math.PI / 2, distance: 8, color: 'salmon', name: title + ' 2' },
        { angle: Math.PI, distance: 11, color: 'lightgreen', name: title + ' 3' }
      ];

      planetData.forEach(data => {
        const planetGeometry = new THREE.SphereGeometry(1, 32, 32);
        const planetMaterial = new THREE.MeshStandardMaterial({ color: data.color });
        const planet = new THREE.Mesh(planetGeometry, planetMaterial);
        planet.userData = { angle: data.angle, distance: data.distance, name: data.name };
        planet.position.set(data.distance * Math.cos(data.angle), 0, data.distance * Math.sin(data.angle));
        group.add(planet);
      });

      scene.add(group);
      solarSystems.push(group);
    }

    const solarSystems = [];
    createSolarSystem(new THREE.Vector3(-30, 0, 0), 'Projects');
    createSolarSystem(new THREE.Vector3(30, 0, 0), 'Experience');
    createSolarSystem(new THREE.Vector3(0, 20, -20), 'Skills');

    // Raycaster pour gérer les clics
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    function onClick(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children, true);
      if (intersects.length > 0) {
        const obj = intersects[0].object;
        alert(obj.name || obj.userData.name || 'Objet cliqué');
      }
    }
    window.addEventListener('click', onClick, false);

    // Animation
    function animate() {
      requestAnimationFrame(animate);

      // Rotation et animation des systèmes solaires
      solarSystems.forEach(system => {
        system.rotation.y += 0.001;
        system.children.forEach(child => {
          if (child.userData && child.userData.distance) {
            const elapsed = Date.now() * 0.0002;
            const angle = child.userData.angle + elapsed;
            child.position.x = child.userData.distance * Math.cos(angle);
            child.position.z = child.userData.distance * Math.sin(angle);
          }
        });
      });

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
